{"version":3,"sources":["C:/a/FastNet/Web/FastNet.Web.Client/node_modules/angular-archwizard/fesm2015/angular-archwizard.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;CASC,2LAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BD,uLAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4MAyID;;;;;;;;;;;;;AAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6FA2CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CA;;;;;;;;;;;;;;;;0BAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgwBD,6HAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoHD,2KAMC;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6DD;;;;;;;;;;;;;0BAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiDD,2KAKC;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuJD,6JAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DD,uGAKC;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4CD,+HAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6DD,uGAKC;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CD,6CAKC;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD,+HAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CD;;;;;;;;;;;;;;;0BAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DD;;;;;;;;;;;;0BAWC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6ED,4SAKC;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD,6MAKC;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA6CC","file":"angular-archwizard.js","sourcesContent":["import { Directive, TemplateRef, EventEmitter, ContentChild, Input, Output, HostBinding, Component, forwardRef, ContentChildren, Host, Optional, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStepSymbol` directive can be used as an alternative to the `navigationSymbol` input of a [[WizardStep]]\n * to define the step symbol inside the navigation bar.  This way step symbol may contain arbitrary content.\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepSymbol>\n *     ...\n * </ng-template>\n * ```\n */\nclass WizardStepSymbolDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} templateRef A reference to the content of the `ng-template` that contains this [[WizardStepSymbolDirective]]\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nWizardStepSymbolDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[awStepSymbol], ng-template[awWizardStepSymbol]'\n            },] }\n];\n/** @nocollapse */\nWizardStepSymbolDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStepTitle` directive can be used as an alternative to the `stepTitle` input of a [[WizardStep]]\n * to define the content of a step title inside the navigation bar.\n * This step title can be freely created and can contain more than only plain text\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepTitle>\n *     ...\n * </ng-template>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardStepTitleDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} templateRef A reference to the content of the `ng-template` that contains this [[WizardStepTitleDirective]]\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nWizardStepTitleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[awStepTitle], ng-template[awWizardStepTitle]'\n            },] }\n];\n/** @nocollapse */\nWizardStepTitleDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Basic functionality every type of wizard step needs to provide\n *\n * @author Marc Arndt\n * @abstract\n */\nclass WizardStep {\n    constructor() {\n        /**\n         * A symbol property, which contains an optional symbol for the step inside the navigation bar.\n         * Takes effect when `stepSymbolTemplate` is not defined or null.\n         */\n        this.navigationSymbol = { symbol: '' };\n        /**\n         * A boolean describing if the wizard step is currently selected\n         */\n        this.selected = false;\n        /**\n         * A boolean describing if the wizard step has been completed\n         */\n        this.completed = false;\n        /**\n         * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user\n         *\n         * Users will typically use `CompletedStepDirective` to set this flag\n         */\n        this.initiallyCompleted = false;\n        /**\n         * A boolean describing if the wizard step is being edited after being competed\n         *\n         * This flag can only be true when `selected` is true.\n         */\n        this.editing = false;\n        /**\n         * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step\n         */\n        this.defaultSelected = false;\n        /**\n         * A boolean describing if the wizard step is an optional step\n         */\n        this.optional = false;\n        /**\n         * A function or boolean deciding, if this step can be entered\n         */\n        this.canEnter = true;\n        /**\n         * A function or boolean deciding, if this step can be exited\n         */\n        this.canExit = true;\n        /**\n         * This [[EventEmitter]] is called when the step is entered.\n         * The bound method should be used to do initialization work.\n         */\n        this.stepEnter = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called when the step is exited.\n         * The bound method can be used to do cleanup work.\n         */\n        this.stepExit = new EventEmitter();\n    }\n    /**\n     * Returns if this wizard step should be visible to the user.\n     * If the step should be visible to the user false is returned, otherwise true\n     * @return {?}\n     */\n    get hidden() {\n        return !this.selected;\n    }\n    /**\n     * This method returns true, if this wizard step can be transitioned with a given direction.\n     * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n     *\n     * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n     * @private\n     * @param {?} condition A condition variable, deciding if the step can be transitioned\n     * @param {?} direction The direction in which this step should be transitioned\n     * @return {?} A [[Promise]] containing `true`, if this step can transitioned in the given direction\n     */\n    static canTransitionStep(condition, direction) {\n        if (typeof (condition) === typeof (true)) {\n            return Promise.resolve((/** @type {?} */ (condition)));\n        }\n        else if (condition instanceof Function) {\n            return Promise.resolve(condition(direction));\n        }\n        else {\n            return Promise.reject(new Error(`Input value '${condition}' is neither a boolean nor a function`));\n        }\n    }\n    /**\n     * A function called when the step is entered\n     *\n     * @param {?} direction The direction in which the step is entered\n     * @return {?}\n     */\n    enter(direction) {\n        this.stepEnter.emit(direction);\n    }\n    /**\n     * A function called when the step is exited\n     *\n     * @param {?} direction The direction in which the step is exited\n     * @return {?}\n     */\n    exit(direction) {\n        this.stepExit.emit(direction);\n    }\n    /**\n     * This method returns true, if this wizard step can be entered from the given direction.\n     * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be entered\n     * @return {?} A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n     */\n    canEnterStep(direction) {\n        return WizardStep.canTransitionStep(this.canEnter, direction);\n    }\n    /**\n     * This method returns true, if this wizard step can be exited into given direction.\n     * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be left\n     * @return {?} A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n     */\n    canExitStep(direction) {\n        return WizardStep.canTransitionStep(this.canExit, direction);\n    }\n}\nWizardStep.propDecorators = {\n    stepTitleTemplate: [{ type: ContentChild, args: [WizardStepTitleDirective, { static: false },] }],\n    stepSymbolTemplate: [{ type: ContentChild, args: [WizardStepSymbolDirective, { static: false },] }],\n    stepId: [{ type: Input }],\n    stepTitle: [{ type: Input }],\n    navigationSymbol: [{ type: Input }],\n    canEnter: [{ type: Input }],\n    canExit: [{ type: Input }],\n    stepEnter: [{ type: Output }],\n    stepExit: [{ type: Output }],\n    hidden: [{ type: HostBinding, args: ['hidden',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Basic functionality every wizard completion step needs to provide\n *\n * @author Marc Arndt\n * @abstract\n */\nclass WizardCompletionStep extends WizardStep {\n    constructor() {\n        super(...arguments);\n        /**\n         * @inheritDoc\n         */\n        this.stepExit = new EventEmitter();\n        /**\n         * @inheritDoc\n         */\n        this.canExit = false;\n    }\n    /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    enter(direction) {\n        this.completed = true;\n        this.stepEnter.emit(direction);\n    }\n    /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    exit(direction) {\n        // set this completion step as incomplete (unless it happens to be initiallyCompleted)\n        this.completed = this.initiallyCompleted;\n        this.stepExit.emit(direction);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-completion-step` component can be used to define a completion/success step at the end of your wizard\n * After a `aw-wizard-completion-step` has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a `aw-wizard-completion-step` automatically sets the `aw-wizard` and all steps inside the `aw-wizard`\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'navigation symbol font family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardCompletionStepComponent extends WizardCompletionStep {\n}\nWizardCompletionStepComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'aw-wizard-completion-step',\n                template: \"<ng-content></ng-content>\\n\",\n                providers: [\n                    { provide: WizardStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardCompletionStepComponent)) },\n                    { provide: WizardCompletionStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardCompletionStepComponent)) }\n                ]\n            }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The direction in which a step transition was made\n *\n * @author Marc Arndt\n */\n/** @enum {number} */\nconst MovingDirection = {\n    /**\n     * A forward step transition\n     */\n    Forwards: 0,\n    /**\n     * A backward step transition\n     */\n    Backwards: 1,\n    /**\n     * No step transition was done\n     */\n    Stay: 2,\n};\nMovingDirection[MovingDirection.Forwards] = 'Forwards';\nMovingDirection[MovingDirection.Backwards] = 'Backwards';\nMovingDirection[MovingDirection.Stay] = 'Stay';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n * @abstract\n */\nclass BaseNavigationMode {\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * In this implementation, a destination wizard step can be entered if:\n     * - it exists\n     * - the current step can be exited in the direction of the destination step\n     * - the destination step can be entered in the direction from the current step\n     *\n     * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    canGoToStep(wizard, destinationIndex) {\n        /** @type {?} */\n        const hasStep = wizard.hasStep(destinationIndex);\n        /** @type {?} */\n        const movingDirection = wizard.getMovingDirection(destinationIndex);\n        /** @type {?} */\n        const canExitCurrentStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        (previous) => {\n            return previous && wizard.currentStep.canExitStep(movingDirection);\n        });\n        /** @type {?} */\n        const canEnterDestinationStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        (previous) => {\n            return previous && wizard.getStepAtIndex(destinationIndex).canEnterStep(movingDirection);\n        });\n        /** @type {?} */\n        const canTransitionToStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        (previous) => {\n            return previous && this.canTransitionToStep(wizard, destinationIndex);\n        });\n        return Promise.resolve(hasStep)\n            .then(canTransitionToStep)\n            // Apply user-defined checks at the end.  They can involve user interaction\n            // which is better to be avoided if navigation mode does not actually allow the transition\n            // (`canTransitionToStep` returns `false`).\n            .then(canExitCurrentStep)\n            .then(canEnterDestinationStep);\n    }\n    /**\n     * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n     *\n     * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n     * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n     * by previous/next buttons, but not using the navigation bar.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    canTransitionToStep(wizard, destinationIndex) {\n        return this.isNavigable(wizard, destinationIndex);\n    }\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * When entering the destination step, the following actions are done:\n     * - the old current step is set as completed\n     * - the old current step is set as unselected\n     * - the old current step is exited\n     * - the destination step is set as selected\n     * - the destination step is entered\n     *\n     * When the destination step couldn't be entered, the following actions are done:\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    goToStep(wizard, destinationIndex, preFinalize, postFinalize) {\n        this.canGoToStep(wizard, destinationIndex).then((/**\n         * @param {?} navigationAllowed\n         * @return {?}\n         */\n        navigationAllowed => {\n            if (navigationAllowed) {\n                // the current step can be exited in the given direction\n                /** @type {?} */\n                const movingDirection = wizard.getMovingDirection(destinationIndex);\n                /* istanbul ignore if */\n                if (preFinalize) {\n                    preFinalize.emit();\n                }\n                // leave current step\n                wizard.currentStep.completed = true;\n                wizard.currentStep.exit(movingDirection);\n                wizard.currentStep.editing = false;\n                wizard.currentStep.selected = false;\n                this.transition(wizard, destinationIndex);\n                // remember if the next step is already completed before entering it to properly set `editing` flag\n                /** @type {?} */\n                const wasCompleted = wizard.completed || wizard.currentStep.completed;\n                // go to next step\n                wizard.currentStep.enter(movingDirection);\n                wizard.currentStep.selected = true;\n                if (wasCompleted) {\n                    wizard.currentStep.editing = true;\n                }\n                /* istanbul ignore if */\n                if (postFinalize) {\n                    postFinalize.emit();\n                }\n            }\n            else {\n                // if the current step can't be left, reenter the current step\n                wizard.currentStep.exit(MovingDirection.Stay);\n                wizard.currentStep.enter(MovingDirection.Stay);\n            }\n        }));\n    }\n    /**\n     * Transitions the wizard to the given step index.\n     *\n     * Can perform additional actions in particular navigation mode implementations.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step\n     * @return {?}\n     */\n    transition(wizard, destinationIndex) {\n        wizard.currentStepIndex = destinationIndex;\n    }\n    /**\n     * Resets the state of this wizard.\n     *\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n     * In addition the whole wizard is set as incomplete.\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    reset(wizard) {\n        this.ensureCanReset(wizard);\n        // reset the step internal state\n        wizard.wizardSteps.forEach((/**\n         * @param {?} step\n         * @return {?}\n         */\n        step => {\n            step.completed = step.initiallyCompleted;\n            step.selected = false;\n            step.editing = false;\n        }));\n        // set the first step as the current step\n        wizard.currentStepIndex = wizard.defaultStepIndex;\n        wizard.currentStep.selected = true;\n        wizard.currentStep.enter(MovingDirection.Forwards);\n    }\n    /**\n     * Checks if wizard configuration allows to perform reset.\n     *\n     * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n     *\n     * Can include additional checks in particular navigation mode implementations.\n     *\n     * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    ensureCanReset(wizard) {\n        // the wizard doesn't contain a step with the default step index\n        if (!wizard.hasStep(wizard.defaultStepIndex)) {\n            throw new Error(`The wizard doesn't contain a step with index ${wizard.defaultStepIndex}`);\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\nclass ConfigurableNavigationMode extends BaseNavigationMode {\n    /**\n     * Constructor\n     *\n     * @param {?=} navigateBackward Controls whether wizard steps before the current step are navigable\n     * @param {?=} navigateForward Controls whether wizard steps before the current step are navigable\n     */\n    constructor(navigateBackward = null, navigateForward = null) {\n        super();\n        this.navigateBackward = navigateBackward;\n        this.navigateForward = navigateForward;\n        this.navigateBackward = this.navigateBackward || 'allow';\n        this.navigateForward = this.navigateForward || 'deny';\n    }\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    canTransitionToStep(wizard, destinationIndex) {\n        // if the destination step can be navigated to using the navigation bar,\n        // it should be accessible with [goToStep] as well\n        if (this.isNavigable(wizard, destinationIndex)) {\n            return true;\n        }\n        // navigation with [goToStep] is permitted if all previous steps\n        // to the destination step have been completed or are optional\n        return wizard.wizardSteps\n            .filter((/**\n         * @param {?} step\n         * @param {?} index\n         * @return {?}\n         */\n        (step, index) => index < destinationIndex && index !== wizard.currentStepIndex))\n            .every((/**\n         * @param {?} step\n         * @return {?}\n         */\n        step => step.completed || step.optional));\n    }\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    transition(wizard, destinationIndex) {\n        if (this.navigateForward === 'deny') {\n            // set all steps after the destination step to incomplete\n            wizard.wizardSteps\n                .filter((/**\n             * @param {?} step\n             * @param {?} index\n             * @return {?}\n             */\n            (step, index) => wizard.currentStepIndex > destinationIndex && index > destinationIndex))\n                .forEach((/**\n             * @param {?} step\n             * @return {?}\n             */\n            step => step.completed = false));\n        }\n        super.transition(wizard, destinationIndex);\n    }\n    /**\n     * @inheritDoc\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    isNavigable(wizard, destinationIndex) {\n        // Check if the destination step can be navigated to\n        /** @type {?} */\n        const destinationStep = wizard.getStepAtIndex(destinationIndex);\n        if (destinationStep instanceof WizardCompletionStep) {\n            // A completion step can only be entered, if all previous steps have been completed, are optional, or selected\n            /** @type {?} */\n            const previousStepsCompleted = wizard.wizardSteps\n                .filter((/**\n             * @param {?} step\n             * @param {?} index\n             * @return {?}\n             */\n            (step, index) => index < destinationIndex))\n                .every((/**\n             * @param {?} step\n             * @return {?}\n             */\n            step => step.completed || step.optional || step.selected));\n            if (!previousStepsCompleted) {\n                return false;\n            }\n        }\n        // Apply navigation pocicies\n        if (destinationIndex < wizard.currentStepIndex) {\n            // If the destination step is before current, apply the `navigateBackward` policy\n            switch (this.navigateBackward) {\n                case 'allow': return true;\n                case 'deny': return false;\n                default:\n                    throw new Error(`Invalid value for navigateBackward: ${this.navigateBackward}`);\n            }\n        }\n        else if (destinationIndex > wizard.currentStepIndex) {\n            // If the destination step is after current, apply the `navigateForward` policy\n            switch (this.navigateForward) {\n                case 'allow': return true;\n                case 'deny': return false;\n                case 'visited': return destinationStep.completed;\n                default:\n                    throw new Error(`Invalid value for navigateForward: ${this.navigateForward}`);\n            }\n        }\n        else {\n            // Re-entering the current step is not allowed\n            return false;\n        }\n    }\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @return {?}\n     */\n    ensureCanReset(wizard) {\n        super.ensureCanReset(wizard);\n        // the default step is a completion step and the wizard contains more than one step\n        /** @type {?} */\n        const defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);\n        /** @type {?} */\n        const defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;\n        if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {\n            throw new Error(`The default step index ${wizard.defaultStepIndex} references a completion step`);\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard` component defines the root component of a wizard.\n * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size\n * of its navigation bar.\n *\n * ### Syntax\n * ```html\n * <aw-wizard [navBarLocation]=\"location of navigation bar\" [navBarLayout]=\"layout of navigation bar\">\n *     ...\n * </aw-wizard>\n * ```\n *\n * ### Example\n *\n * Without completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n * </aw-wizard>\n * ```\n *\n * With completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-completion-step>...</aw-wizard-completion-step>\n * </aw-wizard>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardComponent {\n    /**\n     * Constructor\n     */\n    constructor() {\n        /**\n         * The location of the navigation bar inside the wizard.\n         * This location can be either top, bottom, left or right\n         */\n        this.navBarLocation = 'top';\n        /**\n         * The layout of the navigation bar inside the wizard.\n         * The layout can be either small, large-filled, large-empty or large-symbols\n         */\n        this.navBarLayout = 'small';\n        /**\n         * The direction in which the steps inside the navigation bar should be shown.\n         * The direction can be either `left-to-right` or `right-to-left`\n         */\n        this.navBarDirection = 'left-to-right';\n        this._defaultStepIndex = 0;\n        /**\n         * True, if the navigation bar shouldn't be used for navigating\n         */\n        this.disableNavigationBar = false;\n        /**\n         * The navigation mode used to navigate inside the wizard\n         *\n         * For outside access, use the [[navigation]] getter.\n         */\n        this._navigation = new ConfigurableNavigationMode();\n        /**\n         * An array representation of all wizard steps belonging to this model\n         *\n         * For outside access, use the [[wizardSteps]] getter.\n         */\n        this._wizardSteps = [];\n        /**\n         * The index of the currently visible and selected step inside the wizardSteps QueryList.\n         * If this wizard contains no steps, currentStepIndex is -1\n         *\n         * Note: Do not modify this field directly.  Instead, use navigation methods:\n         * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].\n         */\n        this.currentStepIndex = -1;\n    }\n    /**\n     * The initially selected step, represented by its index\n     * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n     * @return {?}\n     */\n    get defaultStepIndex() {\n        // This value can be either:\n        // - the index of a wizard step with a `selected` directive, or\n        // - the default step index, set in the [[WizardComponent]]\n        // This value can be either:\n        // - the index of a wizard step with a `selected` directive, or\n        // - the default step index, set in the [[WizardComponent]]\n        /** @type {?} */\n        const foundDefaultStep = this.wizardSteps.find((/**\n         * @param {?} step\n         * @return {?}\n         */\n        step => step.defaultSelected));\n        if (foundDefaultStep) {\n            return this.getIndexOfStep(foundDefaultStep);\n        }\n        else {\n            return this._defaultStepIndex;\n        }\n    }\n    /**\n     * @param {?} defaultStepIndex\n     * @return {?}\n     */\n    set defaultStepIndex(defaultStepIndex) {\n        this._defaultStepIndex = defaultStepIndex;\n    }\n    /**\n     * Returns true if this wizard uses a horizontal orientation.\n     * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n     *\n     * @return {?} True if this wizard uses a horizontal orientation\n     */\n    get horizontalOrientation() {\n        return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';\n    }\n    /**\n     * Returns true if this wizard uses a vertical orientation.\n     * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n     *\n     * @return {?} True if this wizard uses a vertical orientation\n     */\n    get verticalOrientation() {\n        return this.navBarLocation === 'left' || this.navBarLocation === 'right';\n    }\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        // add a subscriber to the wizard steps QueryList to listen to changes in the DOM\n        this.wizardStepsQueryList.changes.subscribe((/**\n         * @param {?} changedWizardSteps\n         * @return {?}\n         */\n        changedWizardSteps => {\n            this.updateWizardSteps(changedWizardSteps.toArray());\n        }));\n        // initialize the model\n        this.updateWizardSteps(this.wizardStepsQueryList.toArray());\n        // finally reset the whole wizard componennt\n        this.reset();\n    }\n    /**\n     * The WizardStep object belonging to the currently visible and selected step.\n     * The currentStep is always the currently selected wizard step.\n     * The currentStep can be either completed, if it was visited earlier,\n     * or not completed, if it is visited for the first time or its state is currently out of date.\n     *\n     * If this wizard contains no steps, currentStep is null\n     * @return {?}\n     */\n    get currentStep() {\n        if (this.hasStep(this.currentStepIndex)) {\n            return this.wizardSteps[this.currentStepIndex];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * The completeness of the wizard.\n     * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n     * @return {?}\n     */\n    get completed() {\n        return this.wizardSteps.every((/**\n         * @param {?} step\n         * @return {?}\n         */\n        step => step.completed || step.optional));\n    }\n    /**\n     * An array representation of all wizard steps belonging to this model\n     * @return {?}\n     */\n    get wizardSteps() {\n        return this._wizardSteps;\n    }\n    /**\n     * Updates the wizard steps to the new array\n     *\n     * @private\n     * @param {?} wizardSteps The updated wizard steps\n     * @return {?}\n     */\n    updateWizardSteps(wizardSteps) {\n        // the wizard is currently not in the initialization phase\n        if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {\n            this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);\n        }\n        this._wizardSteps = wizardSteps;\n    }\n    /**\n     * The navigation mode used to navigate inside the wizard\n     * @return {?}\n     */\n    get navigation() {\n        return this._navigation;\n    }\n    /**\n     * Updates the navigation mode for this wizard component\n     *\n     * @param {?} navigation The updated navigation mode\n     * @return {?}\n     */\n    set navigation(navigation) {\n        this._navigation = navigation;\n    }\n    /**\n     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n     *\n     * @param {?} stepIndex The to be checked index of a step inside this wizard\n     * @return {?} True if the given `stepIndex` is contained inside this wizard, false otherwise\n     */\n    hasStep(stepIndex) {\n        return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;\n    }\n    /**\n     * Checks if this wizard has a previous step, compared to the current step\n     *\n     * @return {?} True if this wizard has a previous step before the current step\n     */\n    hasPreviousStep() {\n        return this.hasStep(this.currentStepIndex - 1);\n    }\n    /**\n     * Checks if this wizard has a next step, compared to the current step\n     *\n     * @return {?} True if this wizard has a next step after the current step\n     */\n    hasNextStep() {\n        return this.hasStep(this.currentStepIndex + 1);\n    }\n    /**\n     * Checks if this wizard is currently inside its last step\n     *\n     * @return {?} True if the wizard is currently inside its last step\n     */\n    isLastStep() {\n        return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;\n    }\n    /**\n     * Finds the [[WizardStep]] at the given index `stepIndex`.\n     * If no [[WizardStep]] exists at the given index an Error is thrown\n     *\n     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n     * @param {?} stepIndex The given index\n     * @return {?} The found [[WizardStep]] at the given index `stepIndex`\n     */\n    getStepAtIndex(stepIndex) {\n        if (!this.hasStep(stepIndex)) {\n            throw new Error(`Expected a known step, but got stepIndex: ${stepIndex}.`);\n        }\n        return this.wizardSteps[stepIndex];\n    }\n    /**\n     * Finds the index of the step with the given `stepId`.\n     * If no step with the given `stepId` exists, `-1` is returned\n     *\n     * @param {?} stepId The given step id\n     * @return {?} The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n     */\n    getIndexOfStepWithId(stepId) {\n        return this.wizardSteps.findIndex((/**\n         * @param {?} step\n         * @return {?}\n         */\n        step => step.stepId === stepId));\n    }\n    /**\n     * Finds the index of the given [[WizardStep]] `step`.\n     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n     *\n     * @param {?} step The given [[WizardStep]]\n     * @return {?} The found index of `step` or `-1` if the step is not included in the wizard\n     */\n    getIndexOfStep(step) {\n        return this.wizardSteps.indexOf(step);\n    }\n    /**\n     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n     *\n     * @param {?} destinationStep The given destination step\n     * @return {?} The calculated [[MovingDirection]]\n     */\n    getMovingDirection(destinationStep) {\n        /** @type {?} */\n        let movingDirection;\n        if (destinationStep > this.currentStepIndex) {\n            movingDirection = MovingDirection.Forwards;\n        }\n        else if (destinationStep < this.currentStepIndex) {\n            movingDirection = MovingDirection.Backwards;\n        }\n        else {\n            movingDirection = MovingDirection.Stay;\n        }\n        return movingDirection;\n    }\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n     */\n    canGoToStep(destinationIndex) {\n        return this.navigation.canGoToStep(this, destinationIndex);\n    }\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n     * The [[canGoToStep]] method will be called automatically.\n     *\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    goToStep(destinationIndex, preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);\n    }\n    /**\n     * Tries to transition the wizard to the previous step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    goToPreviousStep(preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);\n    }\n    /**\n     * Tries to transition the wizard to the next step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    goToNextStep(preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);\n    }\n    /**\n     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} True if the step can be navigated to, false otherwise\n     */\n    isNavigable(destinationIndex) {\n        return this.navigation.isNavigable(this, destinationIndex);\n    }\n    /**\n     * Resets the state of this wizard.\n     * @return {?}\n     */\n    reset() {\n        this.navigation.reset(this);\n    }\n}\nWizardComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'aw-wizard',\n                template: \"<aw-wizard-navigation-bar\\n  [direction]=\\\"navBarDirection\\\"\\n  *ngIf=\\\"navBarLocation == 'top' || navBarLocation == 'left'\\\"\\n  [ngClass]=\\\"{\\n    vertical: navBarLocation == 'left',\\n    horizontal: navBarLocation == 'top',\\n    small: navBarLayout == 'small',\\n    'large-filled': navBarLayout == 'large-filled',\\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\\n    'large-empty': navBarLayout == 'large-empty',\\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\\n  }\\\">\\n</aw-wizard-navigation-bar>\\n\\n<div [ngClass]=\\\"{\\n  'wizard-steps': true,\\n  vertical: navBarLocation == 'left' || navBarLocation == 'right',\\n  horizontal: navBarLocation == 'top' || navBarLocation == 'bottom'\\n}\\\">\\n  <ng-content></ng-content>\\n</div>\\n\\n<aw-wizard-navigation-bar\\n  [direction]=\\\"navBarDirection\\\"\\n  *ngIf=\\\"navBarLocation == 'bottom' || navBarLocation == 'right'\\\"\\n  [ngClass]=\\\"{\\n    vertical: navBarLocation == 'right',\\n    horizontal: navBarLocation == 'bottom',\\n    small: navBarLayout == 'small',\\n    'large-filled': navBarLayout == 'large-filled',\\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\\n    'large-empty': navBarLayout == 'large-empty',\\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\\n  }\\\">\\n</aw-wizard-navigation-bar>\\n\"\n            }] }\n];\n/** @nocollapse */\nWizardComponent.ctorParameters = () => [];\nWizardComponent.propDecorators = {\n    wizardStepsQueryList: [{ type: ContentChildren, args: [WizardStep,] }],\n    navBarLocation: [{ type: Input }],\n    navBarLayout: [{ type: Input }],\n    navBarDirection: [{ type: Input }],\n    defaultStepIndex: [{ type: Input }],\n    disableNavigationBar: [{ type: Input }],\n    horizontalOrientation: [{ type: HostBinding, args: ['class.horizontal',] }],\n    verticalOrientation: [{ type: HostBinding, args: ['class.vertical',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-navigation-bar` component contains the navigation bar inside a [[WizardComponent]].\n * To correctly display the navigation bar, it's required to set the right css classes for the navigation bar,\n * otherwise it will look like a normal `ul` component.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-navigation-bar></aw-wizard-navigation-bar>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardNavigationBarComponent {\n    /**\n     * Constructor\n     *\n     * @param {?} wizard The state the wizard currently resides in\n     */\n    constructor(wizard) {\n        this.wizard = wizard;\n        /**\n         * The direction in which the wizard steps should be shown in the navigation bar.\n         * This value can be either `left-to-right` or `right-to-left`\n         */\n        this.direction = 'left-to-right';\n    }\n    /**\n     * Returns all [[WizardStep]]s contained in the wizard\n     *\n     * @return {?} An array containing all [[WizardStep]]s\n     */\n    get wizardSteps() {\n        switch (this.direction) {\n            case 'right-to-left':\n                return this.wizard.wizardSteps.slice().reverse();\n            case 'left-to-right':\n            default:\n                return this.wizard.wizardSteps;\n        }\n    }\n    /**\n     * Returns the number of wizard steps, that need to be displaced in the navigation bar\n     *\n     * @return {?} The number of wizard steps to be displayed\n     */\n    get numberOfWizardSteps() {\n        return this.wizard.wizardSteps.length;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `current`\n     */\n    isCurrent(wizardStep) {\n        return wizardStep.selected;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `editing`\n     */\n    isEditing(wizardStep) {\n        return wizardStep.editing;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `done`\n     */\n    isDone(wizardStep) {\n        return wizardStep.completed;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `optional`\n     */\n    isOptional(wizardStep) {\n        return wizardStep.optional;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n     *\n     * The `completed` class is only applied to completion steps.\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `completed`\n     */\n    isCompleted(wizardStep) {\n        return wizardStep instanceof WizardCompletionStep && this.wizard.completed;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n     * A wizard step can be navigated to if:\n     * - the step is currently not selected\n     * - the navigation bar isn't disabled\n     * - the navigation mode allows navigation to the step\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as navigable\n     */\n    isNavigable(wizardStep) {\n        return !wizardStep.selected && !this.wizard.disableNavigationBar &&\n            this.wizard.isNavigable(this.wizard.getIndexOfStep(wizardStep));\n    }\n}\nWizardNavigationBarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'aw-wizard-navigation-bar',\n                template: \"<ul class=\\\"steps-indicator steps-{{numberOfWizardSteps}}\\\">\\n  <li [attr.id]=\\\"step.stepId\\\" *ngFor=\\\"let step of wizardSteps\\\"\\n      [ngClass]=\\\"{\\n        current: isCurrent(step),\\n        editing: isEditing(step),\\n        done: isDone(step),\\n        optional: isOptional(step),\\n        completed: isCompleted(step),\\n        navigable: isNavigable(step)\\n  }\\\">\\n    <a [awGoToStep]=\\\"step\\\">\\n      <div class=\\\"label\\\">\\n        <ng-container *ngIf=\\\"step.stepTitleTemplate\\\" [ngTemplateOutlet]=\\\"step.stepTitleTemplate.templateRef\\\"></ng-container>\\n        <ng-container *ngIf=\\\"!step.stepTitleTemplate\\\">{{step.stepTitle}}</ng-container>\\n      </div>\\n      <div class=\\\"step-indicator\\\" [ngStyle]=\\\"{ 'font-family': step.stepSymbolTemplate ? '' : step.navigationSymbol.fontFamily }\\\">\\n        <ng-container *ngIf=\\\"step.stepSymbolTemplate\\\" [ngTemplateOutlet]=\\\"step.stepSymbolTemplate.templateRef\\\"></ng-container>\\n        <ng-container *ngIf=\\\"!step.stepSymbolTemplate\\\">{{step.navigationSymbol.symbol}}</ng-container>\\n      </div>\\n    </a>\\n  </li>\\n</ul>\\n\"\n            }] }\n];\n/** @nocollapse */\nWizardNavigationBarComponent.ctorParameters = () => [\n    { type: WizardComponent }\n];\nWizardNavigationBarComponent.propDecorators = {\n    direction: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-step` component is used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardStepComponent extends WizardStep {\n}\nWizardStepComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'aw-wizard-step',\n                template: \"<ng-content></ng-content>\\n\",\n                providers: [\n                    { provide: WizardStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardStepComponent)) }\n                ]\n            }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awEnableBackLinks` directive can be used to allow the user to leave a [[WizardCompletionStep]] after is has been entered.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step awEnableBackLinks (stepExit)=\"exit function\">\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Final step\" awEnableBackLinks>\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\nclass EnableBackLinksDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} completionStep The wizard completion step, which should be exitable\n     */\n    constructor(completionStep) {\n        this.completionStep = completionStep;\n        /**\n         * This EventEmitter is called when the step is exited.\n         * The bound method can be used to do cleanup work.\n         */\n        this.stepExit = new EventEmitter();\n    }\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    ngOnInit() {\n        this.completionStep.canExit = true;\n        this.completionStep.stepExit = this.stepExit;\n    }\n}\nEnableBackLinksDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awEnableBackLinks]'\n            },] }\n];\n/** @nocollapse */\nEnableBackLinksDirective.ctorParameters = () => [\n    { type: WizardCompletionStep, decorators: [{ type: Host }] }\n];\nEnableBackLinksDirective.propDecorators = {\n    stepExit: [{ type: Output }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepId]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepId]] and false otherwise\n */\nfunction isStepId(value) {\n    return value.hasOwnProperty('stepId') && !(value instanceof WizardStep);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepIndex]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepIndex]] and false otherwise\n */\nfunction isStepIndex(value) {\n    return value.hasOwnProperty('stepIndex');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepOffset]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepOffset]] and false otherwise\n */\nfunction isStepOffset(value) {\n    return value.hasOwnProperty('stepOffset');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awGoToStep` directive can be used to navigate to a given step.\n * This step can be defined in one of multiple formats\n *\n * ### Syntax\n *\n * With absolute step index:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepIndex: absolute step index }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With unique step id:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepId: 'step id of destination step' }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With a wizard step object:\n *\n * ```html\n * <button [awGoToStep]=\"wizard step object\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With an offset to the defining step:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepOffset: offset }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nclass GoToStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizard The wizard component\n     * @param {?} wizardStep The wizard step, which contains this [[GoToStepDirective]]\n     */\n    constructor(wizard, wizardStep) {\n        this.wizard = wizard;\n        this.wizardStep = wizardStep;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     * @return {?}\n     */\n    get finalize() {\n        return this.preFinalize;\n    }\n    /**\n     * A convenience name for `preFinalize`\n     *\n     * @param {?} emitter The [[EventEmitter]] to be set\n     * @return {?}\n     */\n    set finalize(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n    }\n    /**\n     * Returns the destination step of this directive as an absolute step index inside the wizard\n     *\n     * @throws If `targetStep` is of an unknown type an `Error` is thrown\n     * @return {?} The index of the destination step\n     */\n    get destinationStep() {\n        /** @type {?} */\n        let destinationStep;\n        if (isStepIndex(this.targetStep)) {\n            destinationStep = this.targetStep.stepIndex;\n        }\n        else if (isStepId(this.targetStep)) {\n            destinationStep = this.wizard.getIndexOfStepWithId(this.targetStep.stepId);\n        }\n        else if (isStepOffset(this.targetStep) && this.wizardStep !== null) {\n            destinationStep = this.wizard.getIndexOfStep(this.wizardStep) + this.targetStep.stepOffset;\n        }\n        else if (this.targetStep instanceof WizardStep) {\n            destinationStep = this.wizard.getIndexOfStep(this.targetStep);\n        }\n        else {\n            throw new Error(`Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId`);\n        }\n        return destinationStep;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the `destinationStep`\n     * @param {?} event\n     * @return {?}\n     */\n    onClick(event) {\n        this.wizard.goToStep(this.destinationStep, this.preFinalize, this.postFinalize);\n    }\n}\nGoToStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awGoToStep]'\n            },] }\n];\n/** @nocollapse */\nGoToStepDirective.ctorParameters = () => [\n    { type: WizardComponent },\n    { type: WizardStep, decorators: [{ type: Optional }] }\n];\nGoToStepDirective.propDecorators = {\n    preFinalize: [{ type: Output }],\n    postFinalize: [{ type: Output }],\n    targetStep: [{ type: Input, args: ['awGoToStep',] }],\n    finalize: [{ type: Output }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awNextStep` directive can be used to navigate to the next step.\n *\n * ### Syntax\n *\n * ```html\n * <button awNextStep (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nclass NextStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizard The state of the wizard\n     */\n    constructor(wizard) {\n        this.wizard = wizard;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     * @return {?}\n     */\n    get finalize() {\n        return this.preFinalize;\n    }\n    /**\n     * A convenience name for `preFinalize`\n     *\n     * @param {?} emitter The [[EventEmitter]] to be set\n     * @return {?}\n     */\n    set finalize(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the next step\n     * @param {?} event\n     * @return {?}\n     */\n    onClick(event) {\n        this.wizard.goToNextStep(this.preFinalize, this.postFinalize);\n    }\n}\nNextStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awNextStep]'\n            },] }\n];\n/** @nocollapse */\nNextStepDirective.ctorParameters = () => [\n    { type: WizardComponent }\n];\nNextStepDirective.propDecorators = {\n    preFinalize: [{ type: Output }],\n    postFinalize: [{ type: Output }],\n    finalize: [{ type: Output }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awOptionalStep` directive can be used to define an optional `wizard-step`.\n * An optional wizard step is a [[WizardStep]] that doesn't need to be completed to transition to later wizard steps.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Second step\" awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nclass OptionalStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizardStep The wizard step, which contains this [[OptionalStepDirective]]\n     */\n    constructor(wizardStep) {\n        this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    ngOnInit() {\n        this.wizardStep.optional = true;\n    }\n}\nOptionalStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awOptionalStep]'\n            },] }\n];\n/** @nocollapse */\nOptionalStepDirective.ctorParameters = () => [\n    { type: WizardStep, decorators: [{ type: Host }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awPreviousStep` directive can be used to navigate to the previous step.\n * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.\n *\n * ### Syntax\n *\n * ```html\n * <button awPreviousStep>...</button>\n * ```\n *\n * @author Marc Arndt\n */\nclass PreviousStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizard The state of the wizard\n     */\n    constructor(wizard) {\n        this.wizard = wizard;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     * @return {?}\n     */\n    get finalize() {\n        return this.preFinalize;\n    }\n    /**\n     * A convenience field for `preFinalize`\n     *\n     * @param {?} emitter The [[EventEmitter]] to be set\n     * @return {?}\n     */\n    set finalize(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the previous step\n     * @param {?} event\n     * @return {?}\n     */\n    onClick(event) {\n        this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);\n    }\n}\nPreviousStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awPreviousStep]'\n            },] }\n];\n/** @nocollapse */\nPreviousStepDirective.ctorParameters = () => [\n    { type: WizardComponent }\n];\nPreviousStepDirective.propDecorators = {\n    preFinalize: [{ type: Output }],\n    postFinalize: [{ type: Output }],\n    finalize: [{ type: Output }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awResetWizard` directive can be used to reset the wizard to its initial state.\n * This directive accepts an output, which can be used to specify some custom cleanup work during the reset process.\n *\n * ### Syntax\n *\n * ```html\n * <button awResetWizard (finalize)=\"custom reset task\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nclass ResetWizardDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizard The wizard component\n     */\n    constructor(wizard) {\n        this.wizard = wizard;\n        /**\n         * An [[EventEmitter]] containing some tasks to be done, directly before the wizard is being reset\n         */\n        this.finalize = new EventEmitter();\n    }\n    /**\n     * Resets the wizard\n     * @param {?} event\n     * @return {?}\n     */\n    onClick(event) {\n        // do some optional cleanup work\n        this.finalize.emit();\n        // reset the wizard to its initial state\n        this.wizard.reset();\n    }\n}\nResetWizardDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awResetWizard]'\n            },] }\n];\n/** @nocollapse */\nResetWizardDirective.ctorParameters = () => [\n    { type: WizardComponent }\n];\nResetWizardDirective.propDecorators = {\n    finalize: [{ type: Output }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awSelectedStep` directive can be used on a [[WizardStep]] to set it as selected after the wizard initialisation or a reset.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Step title\" awSelectedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nclass SelectedStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizardStep The wizard step, which should be selected by default\n     */\n    constructor(wizardStep) {\n        this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    ngOnInit() {\n        this.wizardStep.defaultSelected = true;\n    }\n}\nSelectedStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awSelectedStep]'\n            },] }\n];\n/** @nocollapse */\nSelectedStepDirective.ctorParameters = () => [\n    { type: WizardStep, decorators: [{ type: Host }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardCompletionStep` directive can be used to define a completion/success step at the end of your wizard\n * After a [[WizardCompletionStep]] has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a [[WizardCompletionStep]] automatically sets the `wizard`, and all steps inside the `wizard`,\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <div awWizardCompletionStep [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'font-family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </div>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardCompletionStepDirective extends WizardCompletionStep {\n}\nWizardCompletionStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awWizardCompletionStep]',\n                providers: [\n                    { provide: WizardStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardCompletionStepDirective)) },\n                    { provide: WizardCompletionStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardCompletionStepDirective)) }\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStep` directive can be used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\nclass WizardStepDirective extends WizardStep {\n}\nWizardStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awWizardStep]',\n                providers: [\n                    { provide: WizardStep, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => WizardStepDirective)) }\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.\n *\n * There are several usage options:\n *\n * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ```\n *\n * ### Option 2. Pass in a custom navigation mode\n *\n * ```typescript\n * import { BaseNavigationMode } from 'angular-archwizard'\n *\n * class CustomNavigationMode extends BaseNavigationMode {\n *\n *   // ...\n * }\n * ```\n *\n * ```typescript\n * \\@Component({\n *   // ...\n * })\n * class MyComponent {\n *\n *   navigationMode = new CustomNavigationMode();\n * }\n * ```\n *\n * ```html\n * <aw-wizard [awNavigationMode]=\"navigationMode\">...</aw-wizard>\n * ```\n *\n * ### Additional Notes\n *\n * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs\n *\n * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without\n *   any inputs or parameters causes the wizard to use the default \"strict\" navigation mode equivalent to\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ````\n */\nclass NavigationModeDirective {\n    /**\n     * @param {?} wizard\n     */\n    constructor(wizard) {\n        this.wizard = wizard;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.wizard.navigation = this.getNavigationMode();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getNavigationMode() {\n        if (this.awNavigationMode) {\n            return this.awNavigationMode;\n        }\n        return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);\n    }\n}\nNavigationModeDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awNavigationMode]',\n            },] }\n];\n/** @nocollapse */\nNavigationModeDirective.ctorParameters = () => [\n    { type: WizardComponent }\n];\nNavigationModeDirective.propDecorators = {\n    awNavigationMode: [{ type: Input }],\n    navigateBackward: [{ type: Input }],\n    navigateForward: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awCompletedStep` directive can be used to make a wizard step initially completed.\n *\n * Initially completed steps are shown as completed when the wizard is presented to the user.\n *\n * A typical use case is to make a step initially completed if it is automatically filled with some derived/predefined information.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awCompletedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * An optional boolean condition can be specified:\n *\n * ```html\n * <aw-wizard-step [awCompletedStep]=\"shouldBeCompleted\">\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"First step\" [awCompletedStep]=\"firstStepPrefilled\">\n *     ...\n * </aw-wizard-step>\n * ```\n */\nclass CompletedStepDirective {\n    /**\n     * Constructor\n     *\n     * @param {?} wizardStep The wizard step, which contains this [[CompletedStepDirective]]\n     */\n    constructor(wizardStep) {\n        this.wizardStep = wizardStep;\n        // tslint:disable-next-line:no-input-rename\n        this.initiallyCompleted = true;\n    }\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    ngOnInit() {\n        // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n        this.wizardStep.initiallyCompleted = this.initiallyCompleted || (/** @type {?} */ (this.initiallyCompleted)) === '';\n    }\n}\nCompletedStepDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[awCompletedStep]'\n            },] }\n];\n/** @nocollapse */\nCompletedStepDirective.ctorParameters = () => [\n    { type: WizardStep, decorators: [{ type: Host }] }\n];\nCompletedStepDirective.propDecorators = {\n    initiallyCompleted: [{ type: Input, args: ['awCompletedStep',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The module defining all the content inside `angular-archwizard`\n *\n * @author Marc Arndt\n */\nclass ArchwizardModule {\n    /* istanbul ignore next */\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return {\n            ngModule: ArchwizardModule,\n            providers: [\n            // Nothing here yet\n            ]\n        };\n    }\n}\nArchwizardModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    WizardComponent,\n                    WizardStepComponent,\n                    WizardNavigationBarComponent,\n                    WizardCompletionStepComponent,\n                    GoToStepDirective,\n                    NextStepDirective,\n                    PreviousStepDirective,\n                    OptionalStepDirective,\n                    WizardStepSymbolDirective,\n                    WizardStepTitleDirective,\n                    EnableBackLinksDirective,\n                    WizardStepDirective,\n                    WizardCompletionStepDirective,\n                    SelectedStepDirective,\n                    ResetWizardDirective,\n                    NavigationModeDirective,\n                    CompletedStepDirective,\n                ],\n                imports: [\n                    CommonModule\n                ],\n                exports: [\n                    WizardComponent,\n                    WizardStepComponent,\n                    WizardNavigationBarComponent,\n                    WizardCompletionStepComponent,\n                    GoToStepDirective,\n                    NextStepDirective,\n                    PreviousStepDirective,\n                    OptionalStepDirective,\n                    WizardStepSymbolDirective,\n                    WizardStepTitleDirective,\n                    EnableBackLinksDirective,\n                    WizardStepDirective,\n                    WizardCompletionStepDirective,\n                    SelectedStepDirective,\n                    ResetWizardDirective,\n                    NavigationModeDirective,\n                    CompletedStepDirective,\n                ]\n            },] }\n];\n\nexport { ArchwizardModule, BaseNavigationMode, CompletedStepDirective, ConfigurableNavigationMode, EnableBackLinksDirective, GoToStepDirective, MovingDirection, NavigationModeDirective, NextStepDirective, OptionalStepDirective, PreviousStepDirective, ResetWizardDirective, SelectedStepDirective, WizardCompletionStep, WizardCompletionStepComponent, WizardCompletionStepDirective, WizardComponent, WizardNavigationBarComponent, WizardStep, WizardStepComponent, WizardStepDirective, WizardStepTitleDirective, isStepId, isStepIndex, isStepOffset, WizardStepSymbolDirective as a };\n"]}